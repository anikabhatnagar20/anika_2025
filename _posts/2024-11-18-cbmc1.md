---
layout: post
comments: True
title: CB MC 1 
description: reflection on cb mc 2014 
categories: ['AP CSA']
courses: {'csa': {'week': 5}}
type: ccc
author: Anika Bhatnagar
---

# CB REFLECTION: 38/40 
- Question 6:  almostEqual method
<img width="1029" alt="image" src="https://github.com/user-attachments/assets/014b5f3f-855e-4445-96f7-7941e69fca75">
The other options don’t work because they either don’t properly check the difference or use unrelated calculations, like averaging the numbers. For example, Option A only works if d1≥d2, and B and D compare the average of the numbers, which has nothing to do with their closeness. Option C is completely opposite to the goal because it checks if the difference is greater than the tolerance instead of less. Option E is correct because it accurately checks if the two numbers are close enough by comparing their absolute difference to the tolerance.

- Question 34: Point and circle classes 
<img width="1008" alt="image" src="https://github.com/user-attachments/assets/4e40164e-2afe-45d8-ae26-09b249a4f9ae">
<img width="1075" alt="image" src="https://github.com/user-attachments/assets/503dc8f7-7ade-4865-b1cc-f9ba72a95175">
Option A only checks `d1 - d2`, which doesn't work when `d1 < d2` since the difference becomes negative. Options B and D incorrectly use the average of `d1` and `d2`, which has no relation to how close the two values are. Option C checks if the difference is greater than or equal to the tolerance, which is the opposite of the intended logic. E is the only correct option because it compares the absolute difference of `d1` and `d2` to the tolerance, which is the proper way to determine if two numbers are close enough to be considered equal.

## overall reflection 
The hardest questions for me were the ones that involved tricky concepts like recursion and multi-way selection logic. For example, problems like seqSearchRecHelper change and compute method with parameters n and k were challenging because they required me to carefully think through how the code would work step by step. These types of questions tested my understanding of how to handle complex logic and edge cases.
One thing I still need to work on is understanding recursive methods better. I was able to get the right answers, but I often needed help or had to look things up online. I also found questions about interfaces, like Vehicle interface getMileage, to be tricky because I need to improve my knowledge of object-oriented programming concepts. Practicing these areas more will help me feel more confident solving similar problems on my own

Some of the questions I found easy were those involving straightforward logic or basic operations, like sumArray with 1D int array and Print odd integers in 1D array but not even. These types of problems required simple loops or conditional checks, which I am comfortable with. I also found questions about instantiating objects, like Instantiation of Student objects, to be easy because they followed basic object-oriented programming principles that I’ve practiced before.
